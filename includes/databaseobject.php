<?php 
/*
* 
*/
abstract class DatabaseObject#encapsulating any object which will interect with db
{
    #this class is here for allowing interaction of any kind of object with
    #database (example- users etc), we will create class user and make it to inherited by it

 protected static $table_name='users';#default table_name each class will have its own
 protected static $db_fields=array();//we will definitely have id so we can initialise not necessary
 /* PUBLIC METHODS
  *  these methods will be called after creating Object 
  */
  public function create() {//SYNCHRONISE DB data with object
    /*
     *this method will create user and store it to the database 
     *user object has been already created and all info has been 
     *pushed into it except id(not known)
     *abstract as each Object has its own different types
     *protected so that could not be called directly
     */ 
      //RETURN TRUE IF SUCCESSFUL ELSE FALSE

      //overriding abstract create() function of databaseobject
   // insert the current user to database
        global $database;

//         $sql= "INSERT INTO users ("; 
        $sql= "INSERT INTO ".static::$table_name." (";

//       $sql.=" username,password,first_name,last_name ";
        /*for making it generalise we have two choices
         * 1- use get_object_vars() - but is returns all attributes of class(including private), but we only need database attributes
         * 2- use a array in each database object subclass which contains all 
         */
        
        $attributes=$this->sanitized_attributes();//fetching db attributes(because it is dbobject)    
        
        array_shift($attributes);//slicing off the key attribute so that we are not going to insert it otherwise error will occur
        
        $sql.=join(",",array_keys($attributes));//attributes are associative array
        $sql.=" ) VALUES ('";
        
    /*  REPLACED BY FOLLOWING FOR GENERALISATION  
       $sql.=$database->escape_value($this->username);
        $sql.=" ' , ' ".$database->escape_value($this->password);
        $sql.=" ' , ' ".$database->escape_value($this->first_name);
        $sql.=" ' , ' ".$database->escape_value($this->last_name);
        $sql.=" ') ";
      */ 
        //slicing is not required here as id has null which will automatically not comes because this function only returns non null values
        $sql.=join("','",array_values($attributes));
        $sql.="')";
        if($database->query($sql)){
          #if successfully inserted return true
            $this->id=$database->insert_id();//return last inserted id
             // id will be generated by database so we are fetching 
            // that and storing it in our user object
           return true;//if query successful
         }
        #we need not to write else because script will die as the query fails 
        #from query() function
         return false;//if failed
    }
     public function update() {//SYNCHRONISE DB data with object
        #update info of object in DB updated already in Object
        #protected so that could not be called directly

         global $database;
        
       /* REPLACED WITH FOLLOWING DATA FOR GENERALISATION
        $attributes=$this->attributes();
        $sql.="username='".$database->escape_value($this->username);
        $sql.="', password='".$database->escape_value($this->password);
        $sql.="', first_name='".$database->escape_value($this->first_name);
        $sql.="', last_name='".$database->escape_value($this->last_name)."'";
        $sql.="WHERE id=".$database->escape_value($this->id);
        */ 
        $attributes=$this->sanitized_attributes();//fetching db attributes(because it is dbobject) 
        //creating a new array of strings because here we need '=' between values
        $attribute_pair=array();
        foreach($attributes as $key=>$value){
            $attribute_pair[]="{$key} ='{$value}'"; 
        }
        $sql= "UPDATE ".static::$table_name." SET ";
        $sql.=join(",",$attribute_pair);
        $sql.=" WHERE id=".$database->escape_value($this->id);
        $database->query($sql);
         return ($database->affected_rows()==1)? true:false;
            //to know successfull update we have to use 
            //if affected rows in previous query is 1(0 or 1 possible)
       }
  
  public function save(){//save in db
     /* 
      * this is a combination of create() and update()
      *  will update if this id already created because 
      *  id get assigned in create()
      *  willbe same for all objects
      */
     if(isset($this->id)){
      
         //if id already assigned
         $this->update();
     }else{
         //if object has no id,assign it 
         $this->create();
     }
 }//SYNCHRONISE DB data with object
 
 public function delete(){//delete object from db
     global $database;
     #this will delete data give by id
     $sql= "DELETE FROM ".static::$table_name;
     $sql.=" WHERE id=".$database->escape_value($this->id);
     $sql.=" LIMIT 1";
     $database->query($sql);
      return ($database->affected_rows()==1)?true:false;
     #in insert true/false return, in others we have to 
      # check by affected rows
     }//SYNCHRONISE DB data with object

 
     # delete the data of caller Object from database
 /*STATIC METHODS
 these methods will be used to get the information about an Object
 from DB and giving them as an object.
    */
    public static function find_all()  {
        #this method return all users as objects
        $sql="SELECT * FROM ".static::$table_name;
        return static::find_by_sql($sql);
        /*
        due to static binding the self::$table_name turns out to be DatabaseObject::$table_name which is always 'users' (given default)
        and not the class inheriting it.
        so we have to use static in place of self which will make it to generate class name at runtime.
        */
    }

 public static function find_by_id($id)
    {   global $database;
        $id=$database->escape_value($id);
        #this method return returns information of a user
        $sql="SELECT * FROM ".static::$table_name." WHERE id={$id} LIMIT 1 ";
        $object_array = static::find_by_sql($sql);
        return  !empty($object_array)?array_shift($object_array):false;
        //if array is empty retu rn false else return first element
    }

 public static function find_by_sql($sql) 
    {
        #this method return result from user table according to $sql
        global $database;//database connection comes from global
        $result_set = $database->query($sql);
        //        return $result_set;
        // now we are modifying the code to return object array in place
        // of records
     $object_array=array();
     while($result=$database->fetch_assoc($result_set)){
            $object_array[]=static::instantiate($result);
            //this will return the object which will be appended to $Object_array
     } 
       return $object_array;
    }
 
  
    
    
    
//PRIVATE METHODS
//this fn will not be called from outside of class
 private  static function instantiate($result){
        //this function create a object of user and assign all value of $result to $object and return object
      
      /* THIS WAS SPECIALLY FOR USER, SO WE ARE MAKING IT FOR ALL TYPES
       * ALSO WE HAVE TO WRITE ALL ATTRIBUTES BY HAND WHICH IS NOT THAT GOOD
        
        $object->id=$result['id'];
        $object->username=$result['username'];
        $object->password=$result['password'];
        $object->first_name=$result['first_name'];
        $object->last_name=$result['last_name'];

      */
     /*  $object=new self;//ex- object=new User()
        DUE TO EARLY STATIC BINDING self will always become databaseobject WE HAVE TO CONVERT INTO FOLLOWING
     */
        $class_name=get_called_class();//name of class is returned from which we are calling that function
        $object=new $class_name;//class object is made by name
         foreach ($result as $key => $value) {
            if($object->has_attribute($key)){
                $message =" in instantiate";
                $message.="key: {$key} and value: {$value}<br>";
                //has_attribute  checks if a key is present in an object
                $object->$key=$value;
            }
        }
       return $object;//
    }
protected function attributes(){
     global $database;
    //this function returns a associative array such as
     // $attributes=>value, if no value return null (same as get_object_vars())

     //here we are escaping value and then return
     $attribute=array();
     foreach(static::$db_fields as $field){
         //here if we use static::$db_fields then it is not working
        if (property_exists($this, $field)) {
                $attribute[$field] = $database->escape_value($this->$field);
            }
        } 
    return $attribute;
}
protected function sanitized_attributes(){
    global $database;
    $clean_attributes=array();
    $attributes=$this->attributes();
    foreach($attributes as $key => $value){
        $clean_attributes[$key]=$database->escape_value($value);
   }
   return $clean_attributes;
}
private function has_attribute($attribute){
        //get_object_vars() return an associative array with attribute_name and value for an object
        
/* IT IS NOT GOOD TO USE get_object_vars because it return all attributes which are 
 * accesible to $this which may not be of database but we need only of database
 * so we make a method which will return attributes from prestored array   
 *     $attribute_array=get_object_vars($this);
 */
     $attribute_array=$this->attributes();//sanitized not needed
     return array_key_exists($attribute, $attribute_array);
        }
 }



 ?>